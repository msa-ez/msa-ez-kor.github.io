{"hash":"2fab052f0bad860b581c456e67dba81b7650fa45","data":{"markdownPage":{"id":"c10b442ada246f7d6087aa379d0352fc","title":"Global Helper","description":"","path":"/custom-template/global-helper/","timeToRead":3,"content":"<h1 id=\"global-helper\"><a href=\"#global-helper\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Global Helper</h1>\n<p>Global Helper란 MSAEZ가 사전 정의하여 내장하고 있는 helper function으로 템플릿 전역에서 사용가능한 Helper를 의미합니다.</p>\n<h2 id=\"1-스티커-관계에-따른-정보-조회\"><a href=\"#1-%EC%8A%A4%ED%8B%B0%EC%BB%A4-%EA%B4%80%EA%B3%84%EC%97%90-%EB%94%B0%EB%A5%B8-%EC%A0%95%EB%B3%B4-%EC%A1%B0%ED%9A%8C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1. 스티커 관계에 따른 정보 조회</h2>\n<p>템플릿 파일에서 forEach로 지정한 스티커의 정보 뿐만이 아니라 다른 스티커의 정보를 필요로 할 때가 있습니다. </p>\n<p>모델링을 기준으로 각 스티커간의 관계는 다음과 같습니다.</p>\n<p><img src=\"https://github.com/msa-ez/platform/assets/123912988/f5c505b1-4e38-426b-a5e6-27aac19db6d2\"></p>\n<p>위의 예시에서 설명된 스티커간의 관계를 이용하여 Global Helper를 사용하는 방법은 다음과 같습니다.</p>\n<h3 id=\"11-attached\"><a href=\"#11-attached\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1.1 attached</h3>\n<p>'attached'는 기준이 되는 스티커에 부착된 다른 스티커의 정보를 불러올 때 사용할 수 있습니다.</p>\n<p>모델링 단계에서 서로다른 부착된 스티커가 있을때 사용가능하며</p>\n<p>Aggregate 스티커 'Order'에서 부착된 Event 스티커 'OrderPlaced'의 정보를 필요로 한다고 가정했을 때, 아래와 같이 사용할 수 있습니다.</p>\n<p>Template</p>\n<pre class=\"language-text\"><code class=\"language-text\">{{#attached &#39;Event&#39; this}}\n    {{name}}\n{{/attached}}</code></pre>\n<p>Template Result</p>\n<pre class=\"language-text\"><code class=\"language-text\">OrderPlaced </code></pre>\n<p>예시처럼 'attached' helper를 사용하기 위해서는 인자값으로 부착된 스티커의 타입을 보내야 합니다.</p>\n<p>여기서는 Event 스티커의 타입 Event를 인자값으로 보냈습니다.</p>\n<p>이때, 'attached'를 통해 부착된 스티커의 타입을 판별하고, Event가 존재함으로써 OrderPlaced 스티커의 정보를 불러올 수 있게 됩니다.</p>\n<h3 id=\"12-outgoing\"><a href=\"#12-outgoing\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1.2 outgoing</h3>\n<p>'outgoing'은 기준이 되는 스티커와 outgoingRelation 관게가 형성된 다른 스티커의 정보를 가져올 때 사용합니다.</p>\n<p>모델링 단계에서 스티커간 outgoingRelation관계가 형성되어있다면 아래와 같이 사용가능합니다.</p>\n<p>Template</p>\n<pre class=\"language-text\"><code class=\"language-text\">{{#outgoing &#39;Event&#39; this}}\n    {{#camelCase name}}\n{{/outgoing}}</code></pre>\n<p>Template Result</p>\n<pre class=\"language-text\"><code class=\"language-text\">orderPlaced</code></pre>\n<p>예시처럼 'outgoing' helper를 사용하기 위해서는 인자값으로 연결된 스티커의 타입을 보내야 합니다.</p>\n<p>여기서는 커맨드 스티커 'order'와 이벤트 스티커 'OrderPlaced'가 outgoingRelation관계가 형성되어 있어 이벤트 스티커의 유형을 인자값으로 보냈습니다.</p>\n<p>이때, 'outgoing'를 통해 outgoingRelation관계가 형성 되어 있는지를 판별한 후, 형성된 스티커의 정보를 불러오기 때문에 연결된 Event 스티커 'OrderPlaced'의 정보를 가져오게 됩니다.</p>\n<h3 id=\"13-incoming\"><a href=\"#13-incoming\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1.3 incoming</h3>\n<p>'incoming'은 'outgoing'과 반대로 기준이 되는 스티커와 incomingRelation관게가 형성된 스티커의 정보를 가져올 때 사용합니다.</p>\n<p>이번에는 이벤트 스티커 'OrderPlaced'기준 incomingRelation관게를 형성하고 있는 커맨드 스티커 'order'의 정보를 조회해보겠습니다.</p>\n<p>Template</p>\n<pre class=\"language-text\"><code class=\"language-text\">{{#incoming &#39;Command&#39; this}}\n    {{#pascalCase name}}\n{{/incoming}}</code></pre>\n<p>Template Result</p>\n<pre class=\"language-text\"><code class=\"language-text\">Order</code></pre>\n<p>예시처럼 'incoming' helper를 사용하기 위해서는 인자값으로 연결된 스티커의 타입을 보내야 합니다.</p>\n<p>이때, incomingRelation관계가 형성 되어 있는지를 판별한 후 형성된 스티커의 정보를 불러오기 때문에 연결된 Command 스티커 'order'의 정보를 가져오게 됩니다.</p>\n<h3 id=\"14-reaching\"><a href=\"#14-reaching\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>1.4 reaching</h3>\n<p>'reaching'은 기준이 되는 스티커와 relation 관계가 형성된 다른 스티커들의 마지막에 위치한 스티커의 정보를 불러올 때 사용할 수 있습니다.</p>\n<p>모델링에서 서로 다른 스티커에 하나 이상의 relation 관계가 형성되어 있다면 사용가능합니다.</p>\n<p>위의 그림처럼 Command 스티커 'order'에서 Event 스티커 'OrderPlaced'로 관계가 형성되었고, 이어서 Policy 스티커 'start delivery'를 지나 이벤트 스티커 'DeliveryStarted'로 relation 관계가 형성되어있을 때, 'order'에서 'DeliveryStarted'스티커의 정보를 아래와 같이 가져올 수 있습니다. </p>\n<p>Template</p>\n<pre class=\"language-text\"><code class=\"language-text\">{{#reaching &#39;Event&#39; this}}\n    {{#camelCase name}}\n{{/incoming}}</code></pre>\n<p>Template Result</p>\n<pre class=\"language-text\"><code class=\"language-text\">deliveryStarted</code></pre>\n<p>'reaching'을 사용하기 위해서는 인자값으로 정보를 가져올 스티커의 타입을 보내야 하며</p>\n<p>커맨드 스티커 'order'와 형성된 relation 관계의 마지막에 위치하는 'DeliveryStarted'의 스티커 타입을 인자값으로 보냈습니다. </p>\n<p>여기서 'reaching' helper function을 통해 스티커간 형성된 관계에 대해 판별하고 마지막에 위치한 이벤트 스티커 'DeliveryStarted'의 정보를 가져올 수 있게 됩니다.</p>\n<h2 id=\"2-속성-평가\"><a href=\"#2-%EC%86%8D%EC%84%B1-%ED%8F%89%EA%B0%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2. 속성 평가</h2>\n<p>속성에 대하여 평가하여 상황에 맞게 결과값을 반환할 수 있는 Global Helper에 대하여 소개드리겠습니다.</p>\n<h3 id=\"21-ifnotnull\"><a href=\"#21-ifnotnull\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2.1 ifNotNull</h3>\n<p>'ifNotNull'은  displayName을 출력할 때 사용합니다.</p>\n<p>Order Aggregate 스티커의 displayName을 '주문정보'로 설정했다고 가정하였을 때, 아래와 같이 사용할 수 있습니다.</p>\n<p>Template</p>\n<pre class=\"language-text\"><code class=\"language-text\">{{#ifNotNull displayName name}}{{/ifNotNull}}</code></pre>\n<p>Template Result</p>\n<pre class=\"language-text\"><code class=\"language-text\">주문정보</code></pre>\n<p>ifNotNull의 인자값으로 displayName과 name을 보내 displayName의 존재여부를 판단하고있습니다.</p>\n<p>여기서는 displayName이 '주문정보'로 존재하고 있기 때문에 결과값으로 '주문정보'가 출력되는 것을 확인할 수 있습니다.</p>\n<h3 id=\"22-ifequals\"><a href=\"#22-ifequals\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2.2 ifEquals</h3>\n<p>ifEquals는 필드내에 속한 속성을 평가하여 조건에 부합되는 경우 코드 블록을 실행할 때 사용할 수 있습니다.</p>\n<p>필드내에 평가할 속성이 존재한다면 아래와 같이 사용할 수 있습니다.</p>\n<p>Template</p>\n<pre class=\"language-text\"><code class=\"language-text\">public class {{#pascalCase name}} {\n\n{{#aggregates.fieldDescriptors}}\n{{#ifEquals isKey &quot;true&quot;}}\n    @Id\n    private {{className}} {{#camelCase name}}\n{{/ifEquals}}\n{{/aggregates.fieldDescriptors}}\n\n}</code></pre>\n<p>Template Result</p>\n<pre class=\"language-text\"><code class=\"language-text\">public class Order {\n\n@Id\nprivate Long id;\n\n}</code></pre>\n<p>ifEquals의 인자값으로는 평가할 속성과 평가할 내용을 보내야 합니다.</p>\n<p>예시에서는 aggregates.fieldDescriptors에 존재하는 필드들의 속성중 isKey를 평가할 속성으로 보내고 평가할 내용으로 \"true\"를 보내었고, 필드 중 id필드에 한해서 코드블록이 실행된 것을 확인할 수 있습니다.</p>\n<h3 id=\"23-checkvo\"><a href=\"#23-checkvo\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>2.3 checkVO</h3>\n<p>'checkVO'는 VO의 존재여부를 파악하여 VO에 한해서만 특정 코드 블록을 실행할 때 사용할 수 있습니다.</p>\n<p>VO란 ValueObject의 약자를 의미합니다.</p>\n<p>필드에 사전에 지정한 VO가 존재할 경우 사용할 수 있으며, VO중 하나인 Address가 있다고 가정하였을 때, 다음과 같이 사용할 수 있습니다. </p>\n<p>Template</p>\n<pre class=\"language-text\"><code class=\"language-text\">public class {{#pascalCase name}} {\n\n    {{#aggregates.fieldDescriptors}}\n        {{#checkVO className}}\n        @embedded\n        private {{className}} {{#camelCase name}};\n        {{/checkVO}}\n    {{/aggregates.fieldDescriptors}}\n}</code></pre>\n<p>Template Result</p>\n<pre class=\"language-text\"><code class=\"language-text\">public class Order {\n    @embedded\n    private Address address;\n\n}</code></pre>\n<p>checkVO의 인자값으로 className을 보내고 있습니다.</p>\n<p>이후 사전에 VO로 지정한 이름과 일치한 className이 존재할 경우 하단의 코드블록을 실행됩니다.</p>\n<p>사전에 지정한 VO는 'Address', 'Payment', 'Weather', 'Money', 'Email', 'Photo' 등이 있으며</p>\n<p>여기서는 Address가 VO로 지정되어 있기 때문에 하단의 코드가 생성된 것을 확인할 수 있습니다.</p>\n","sidebar":"started","next":"","prev":"","headings":[{"depth":1,"value":"Global Helper","anchor":"#global-helper"},{"depth":2,"value":"1. 스티커 관계에 따른 정보 조회","anchor":"#1-스티커-관계에-따른-정보-조회"},{"depth":3,"value":"1.1 attached","anchor":"#11-attached"},{"depth":3,"value":"1.2 outgoing","anchor":"#12-outgoing"},{"depth":3,"value":"1.3 incoming","anchor":"#13-incoming"},{"depth":3,"value":"1.4 reaching","anchor":"#14-reaching"},{"depth":2,"value":"2. 속성 평가","anchor":"#2-속성-평가"},{"depth":3,"value":"2.1 ifNotNull","anchor":"#21-ifnotnull"},{"depth":3,"value":"2.2 ifEquals","anchor":"#22-ifequals"},{"depth":3,"value":"2.3 checkVO","anchor":"#23-checkvo"}]},"allMarkdownPage":{"edges":[{"node":{"path":"/toppings/test-unit/","title":"Unit-Test"}},{"node":{"path":"/toppings/test-microcks/","title":"API Mock Server"}},{"node":{"path":"/toppings/test-messaging/","title":"Contract Test (비동기호출)"}},{"node":{"path":"/toppings/k8s-kubernetes/","title":"Kubernetes"}},{"node":{"path":"/toppings/test-contract/","title":"Contract Test (동기호출)"}},{"node":{"path":"/tool/setup-on-prem/","title":"Running on Docker Compose (with Github)"}},{"node":{"path":"/toppings/cicd-git-action/","title":"Github Action"}},{"node":{"path":"/toppings/cicd-argo/","title":"Argo"}},{"node":{"path":"/tool/si-gpt/","title":""}},{"node":{"path":"/tool/pbc-marketplace/","title":"컴포저블 엔터프라이즈 구현을 위한 PBCs(Packaged Business Capabilities)"}},{"node":{"path":"/tool/plsql-2-java/","title":"Legacy Modernizer"}},{"node":{"path":"/tool/on-prem-inst-gitea/","title":"on-prem 설치 설명서"}},{"node":{"path":"/tool/on-prem-inst/","title":"on-prem 설치 설명서"}},{"node":{"path":"/tool/marketplace/","title":"마켓플레이스"}},{"node":{"path":"/tool/model-driven/","title":"코드 생성"}},{"node":{"path":"/tool/infrastructure-modeling/","title":"인프라 모델링 (쿠버네티스)"}},{"node":{"path":"/tool/k8s-modeling/","title":"K8s 배포 모델링"}},{"node":{"path":"/tool/google-drive-examples/","title":"Quick Start"}},{"node":{"path":"/tool/event-storming-tool/","title":"이벤트스토밍"}},{"node":{"path":"/tool/event-monitoring/","title":"이벤트 모니터링"}},{"node":{"path":"/tool/deepseek-ai/","title":""}},{"node":{"path":"/tool/development-practice/","title":"강의 개발 및 실습 환경"}},{"node":{"path":"/tool/ddl-to-eventstorming/","title":"DDL To EventStorming"}},{"node":{"path":"/tool/cloud-ide-tool/","title":"클라우드 IDE"}},{"node":{"path":"/tool/bc-domain-gen/","title":"자연어 기반 Bounded Context & 도메인 설계 AI"}},{"node":{"path":"/tool/chat-gpt/","title":"AI 기반 모델 생성"}},{"node":{"path":"/tool/aggregate-design/","title":"애그리거트(Aggregate) 설계"}},{"node":{"path":"/tool/attending-lectures/","title":"Attending lectures"}},{"node":{"path":"/templates-language/python-template/","title":"Python Template "}},{"node":{"path":"/templates-language/springboot-java-template/","title":"Spring Boot/Java Template(준비중)"}},{"node":{"path":"/templates-language/go-template/","title":"Go Template"}},{"node":{"path":"/started/","title":"소개"}},{"node":{"path":"/started/vibe-coding/","title":"Vibe Coding"}},{"node":{"path":"/started/key-features/","title":"주요 기능"}},{"node":{"path":"/started/domain-driven/","title":"도메인 주도 설계 학습"}},{"node":{"path":"/started/event-storming-learning/","title":"이벤트스토밍 학습"}},{"node":{"path":"/operation/ops-deploy-diagramming-basic-objects/","title":"12st Mall Basic Deploy"}},{"node":{"path":"/operation/ops-deploy-diagramming-advanced-pvc/","title":"Persistent Volume"}},{"node":{"path":"/operation/ops-deploy-diagramming-advanced-hpa/","title":"자동확장(HPA) 배포"}},{"node":{"path":"/operation/ops-deploy-diagramming-advanced-istio/","title":"Istio Mesh"}},{"node":{"path":"/operation/ops-deploy-diagramming-advanced-ingress/","title":"Ingress 배포모델 설계"}},{"node":{"path":"/info/pricing/","title":"가격 정책"}},{"node":{"path":"/info/partnership/","title":"파트너 프로그램"}},{"node":{"path":"/example-scenario/library-system/","title":"도서관 시스템"}},{"node":{"path":"/info/consulting/","title":"컨설팅"}},{"node":{"path":"/info/company/","title":"기업 사례"}},{"node":{"path":"/example-scenario/food-delivery/","title":"음식배달"}},{"node":{"path":"/example-scenario/animal-hospital/","title":"동물병원 진료시스템"}},{"node":{"path":"/example-scenario/online-lecture/","title":"인터넷 강의수강 시스템"}},{"node":{"path":"/example-scenario/accommodation-reservation/","title":"숙소예약"}},{"node":{"path":"/development/understanding-jpa-based-single-microservice/","title":"마이크로서비스 구현 및 동작원리 이해"}},{"node":{"path":"/development/token-based-auth/","title":"JWT Token 기반 인증 인가"}},{"node":{"path":"/development/pubsub-idempotency/","title":"Pub/Sub 방식의 연동 - Choreography with Idempotency"}},{"node":{"path":"/development/pubsub-deadline/","title":"Pub/Sub 방식의 연동 - Choreography with Deadline added"}},{"node":{"path":"/development/pub-sub/","title":"Pub/Sub 방식의 연동 "}},{"node":{"path":"/development/orchestration-saga/","title":"Orchestration Saga with Axon Framework"}},{"node":{"path":"/development/ops-docker/","title":"Application Packaging with Container (Docker)"}},{"node":{"path":"/development/kafka-scaling-concurrenty-handling/","title":"Kafka scaling & Concurrenty handling"}},{"node":{"path":"/development/monolith-2-misvc/","title":"Req/Res 방식의 MSA 연동 "}},{"node":{"path":"/development/oauth2with-keycloak/","title":"JWT Token 기반 인증 인가"}},{"node":{"path":"/development/kafka-retry-dlq/","title":"Kafka Retry & Dead Letter Queue "}},{"node":{"path":"/development/kafka-scaling/","title":"Kafka Scaling "}},{"node":{"path":"/development/kafka-connect/","title":"CDC(Change Data Capture) with Kafka"}},{"node":{"path":"/development/kafka-basic/","title":"Kafka 기본 명령어 "}},{"node":{"path":"/development/dp-graphql/","title":"Data Projection with GraphQL"}},{"node":{"path":"/development/dp-frontend/","title":"Data Projection with Frontend and HATEOAS"}},{"node":{"path":"/development/gateway/","title":"API Gateway"}},{"node":{"path":"/development/dp-cqrs/","title":"Data Projection with CQRS"}},{"node":{"path":"/development/contract-test/","title":"Contract Test (Consumer Driven Test)"}},{"node":{"path":"/development/conteact-messaging/","title":"Conteact Test by Message-based CDC"}},{"node":{"path":"/development/compensation-correlation/","title":"Pub/Sub 방식의 연동 - Compensation 과 Correlation"}},{"node":{"path":"/development/cna-start/","title":"단위 마이크로 서비스의 실행 "}},{"node":{"path":"/development/circuit-breaker/","title":"Req/Res 방식에서 장애전파 차단 - 서킷브레이커 "}},{"node":{"path":"/custom-template/understanding-template-structure/","title":"템플릿 구조의 이해"}},{"node":{"path":"/development/choreography-saga/","title":"Choreography Saga"}},{"node":{"path":"/custom-template/unit-test/","title":"테스트 자동화"}},{"node":{"path":"/custom-template/tutorial/","title":"커스텀 템플릿 개념"}},{"node":{"path":"/custom-template/template-syntax/","title":"Template 문법의 이해"}},{"node":{"path":"/custom-template/template-editor/","title":"Template Editor"}},{"node":{"path":"/custom-template/template-structure/","title":"템플릿 파일 구조"}},{"node":{"path":"/custom-template/template-editor-custom-template/","title":"커스텀 템플릿 생성 방법"}},{"node":{"path":"/custom-template/mock-server/","title":"Open API 3.0 기반 목 서버 생성 토핑(New)"}},{"node":{"path":"/custom-template/loop-conditional-statement/","title":"반복문 & 조건문"}},{"node":{"path":"/custom-template/helper/","title":"Helper"}},{"node":{"path":"/custom-template/global-helper/","title":"Global Helper"}},{"node":{"path":"/custom-template/designing-template-helper/","title":"Built-in Helper functions"}},{"node":{"path":"/contact/question/","title":"CONTACT"}},{"node":{"path":"/custom-template/custom-template/","title":"Eventstorming Template Objects"}},{"node":{"path":"/custom-template/creating-custom-template-1/","title":"커스텀 템플릿 생성"}},{"node":{"path":"/business/","title":"이벤트스토밍"}},{"node":{"path":"/business/eventstorming-fooddelivery/","title":"[이벤트스토밍] - DDD Food Delivery 예제"}},{"node":{"path":"/business/ddd-google-drive/","title":"[이벤트스토밍] - 구글 드라이브 예제"}}]}},"context":{}}